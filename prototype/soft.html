<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soft Body Sprite Simulation</title>
    <style>
        /* Basic styles to make the canvas fill the entire screen */
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #7991a8;
            /* A dark slate background */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <!-- CDN imports for the physics and rendering libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixijs@8.0.0/dist/pixi.umd.min.js"></script>

    <script>
        // --- Core Setup ---

        // Set up aliases for Matter.js modules for easier access
        const Engine = Matter.Engine;
        const Render = Matter.Render;
        const Runner = Matter.Runner;
        const Composites = Matter.Composites;
        const World = Matter.World;
        const Events = Matter.Events;
        const Body = Matter.Body;
        const Vector = Matter.Vector;

    let pixiApp, engine, world, runner, kapibaraMesh, softBody;
    let orderedBodies = null; // row-major order mapping for mesh vertices
    let bodyGrid = null;      // 2D grid of particle bodies [rows][cols]
        let ground, wallLeft, wallRight, ceiling;
    let debugGrid = null; // Graphics object for debug grid visualization
        let debugGridVisible = true; // Flag to toggle debug grid visibility
    let meshDebugGrid = null; // Graphics object for PIXI mesh debug grid
    let meshDebugGridVisible = true; // Flag to toggle mesh debug grid visibility
    let enablePhysicsMapping = true; // Always enable physics-to-mesh mapping for correct mesh display
    // Parameters for drawing the rectangular mesh grid (set when mesh is created)
    let meshGridParams = null; // { startX, startY, dx, dy, rows, cols }

    // CONTROLS:
    // D - Toggle physics debug grid
    // M - Toggle mesh debug grid
    // P - Toggle physics-to-mesh mapping

        function addWalls() {
            const wallThickness = 50;
            const wallOptions = {
                isStatic: true,
                render: { visible: false } // We don't need to see the physics bodies
            };

            // ground
            ground = Matter.Bodies.rectangle(
                window.innerWidth / 2,
                window.innerHeight - 100 + wallThickness / 2,
                window.innerWidth + wallThickness * 2, // Make it wider to avoid corner gaps
                wallThickness,
                wallOptions
            );

            // ceiling
            ceiling = Matter.Bodies.rectangle(
                window.innerWidth / 2,
                -wallThickness / 2,
                window.innerWidth + wallThickness * 2,
                wallThickness,
                wallOptions
            );

            // left wall
            wallLeft = Matter.Bodies.rectangle(
                -wallThickness / 2,
                window.innerHeight / 2,
                wallThickness,
                window.innerHeight,
                wallOptions
            );

            // right wall
            wallRight = Matter.Bodies.rectangle(
                window.innerWidth + wallThickness / 2,
                window.innerHeight / 2,
                wallThickness,
                window.innerHeight,
                wallOptions
            );

            World.add(world, [ground, wallLeft, wallRight, ceiling]);
        }

        // --- Initialization Function ---
        function init() {
            // --- Function to create character mesh ---
            function createCharacterMesh(texture, bodyWidth, bodyHeight) {
                // Create MeshPlane (PIXI v8)
                kapibaraMesh = new PIXI.scene.MeshPlane({
                    texture: texture,
                    verticesX: cols,
                    verticesY: rows,
                    width: bodyWidth,
                    height: bodyHeight
                });
                kapibaraMesh.x = 0;
                kapibaraMesh.y = 0;
                pixiApp.stage.addChild(kapibaraMesh);
            }

            // --- Function to setup ordered bodies for debug grids ---
            function setupOrderedBodies() {
                if (!kapibaraMesh || !softBody) return;

                // Simple row-major ordering to match PlaneGeometry exactly
                orderedBodies = [];
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        orderedBodies.push(bodyGrid[r][c]);
                    }
                }
            }
            // 1. PIXI.JS SETUP (RENDERING)
            // Create a Pixi application
            pixiApp = new PIXI.Application({
                width: window.innerWidth,
                height: window.innerHeight,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true,
                backgroundColor: 0x2c3e50,
            });
            document.body.appendChild(pixiApp.view);

            // 2. MATTER.JS SETUP (PHYSICS)
            // Create a physics engine
            engine = Engine.create();
            world = engine.world;
            world.gravity.y = 0.8; // Slightly lower gravity to reduce squashing

            // Create and run the physics engine runner
            runner = Runner.create();
            Runner.run(runner, engine);

            // 3. CREATE THE SOFT BODY (parameters only for now)
            // Define the properties of our soft body grid
            const cols = 10; // reduced resolution for easier debugging
            const rows = 10;
            const particleOptions = {
                friction: 0.05,
                frictionStatic: 0.0,
                frictionAir: 0.03,
                restitution: 0.1,
                render: { visible: false }, // We'll render with Pixi, so hide Matter's default shapes
            };
            const constraintOptions = {
                stiffness: 0.98, // Very stiff to minimize visible grid lines
                damping: 0.5,    // High damping to reduce oscillations
                render: { visible: false }
            };

            // Add level boundaries
            addWalls();


            // 4. CONNECT PHYSICS TO RENDERING
            // Load the sprite texture for Pixi.js
            const texture = PIXI.Texture.from('./sprites/kapibara.png');

            // Build physics body and mesh AFTER the texture loads so we can match its aspect ratio
            texture.baseTexture.once('loaded', () => {
                // Improve texture sampling quality
                texture.baseTexture.scaleMode = PIXI.SCALE_MODES.LINEAR;
                texture.baseTexture.mipmap = PIXI.MIPMAP_MODES.ON;
                const aspect = texture.height / texture.width;
                const maxWidth = Math.min(window.innerWidth * 0.6, texture.width);
                const bodyWidth = maxWidth;
                const bodyHeight = bodyWidth * aspect;

                const startX = window.innerWidth / 2 - bodyWidth / 2;
                const startY = window.innerHeight / 2 - bodyHeight / 2 - 50; // small offset up

                // Compute exact spacing to match mesh dimensions
                const dx = bodyWidth / (cols - 1);
                const dy = bodyHeight / (rows - 1);
                const particleSize = Math.min(dx, dy) * 0.05; // Very small particles to minimize visual impact

                // Create bodies in exact grid positions matching PlaneGeometry
                bodyGrid = Array.from({ length: rows }, () => Array(cols).fill(null));
                const bodies = [];
                
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const x = startX + c * dx;
                        const y = startY + r * dy;
                        const body = Matter.Bodies.circle(x, y, particleSize, particleOptions);
                        bodyGrid[r][c] = body;
                        bodies.push(body);
                    }
                }

                // Create constraints between adjacent bodies
                const constraints = [];
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const current = bodyGrid[r][c];
                        
                        // Horizontal constraint (right neighbor)
                        if (c < cols - 1) {
                            const right = bodyGrid[r][c + 1];
                            constraints.push(Matter.Constraint.create({
                                bodyA: current,
                                bodyB: right,
                                stiffness: constraintOptions.stiffness,
                                damping: constraintOptions.damping,
                                render: { visible: false }
                            }));
                        }
                        
                        // Vertical constraint (bottom neighbor)
                        if (r < rows - 1) {
                            const bottom = bodyGrid[r + 1][c];
                            constraints.push(Matter.Constraint.create({
                                bodyA: current,
                                bodyB: bottom,
                                stiffness: constraintOptions.stiffness,
                                damping: constraintOptions.damping,
                                render: { visible: false }
                            }));
                        }
                        
                        // Cross braces for stability
                        if (r < rows - 1 && c < cols - 1) {
                            const bottomRight = bodyGrid[r + 1][c + 1];
                            constraints.push(Matter.Constraint.create({
                                bodyA: current,
                                bodyB: bottomRight,
                                stiffness: constraintOptions.stiffness * 0.3,
                                damping: constraintOptions.damping,
                                render: { visible: false }
                            }));
                        }
                        
                        if (r < rows - 1 && c > 0) {
                            const bottomLeft = bodyGrid[r + 1][c - 1];
                            constraints.push(Matter.Constraint.create({
                                bodyA: current,
                                bodyB: bottomLeft,
                                stiffness: constraintOptions.stiffness * 0.3,
                                damping: constraintOptions.damping,
                                render: { visible: false }
                            }));
                        }

                        // Add bending constraints (skip-one connections) to reduce grid artifacts
                        if (c < cols - 2) {
                            const rightSkip = bodyGrid[r][c + 2];
                            constraints.push(Matter.Constraint.create({
                                bodyA: current,
                                bodyB: rightSkip,
                                stiffness: constraintOptions.stiffness * 0.2,
                                damping: constraintOptions.damping * 0.5,
                                render: { visible: false }
                            }));
                        }
                        
                        if (r < rows - 2) {
                            const bottomSkip = bodyGrid[r + 2][c];
                            constraints.push(Matter.Constraint.create({
                                bodyA: current,
                                bodyB: bottomSkip,
                                stiffness: constraintOptions.stiffness * 0.2,
                                damping: constraintOptions.damping * 0.5,
                                render: { visible: false }
                            }));
                        }
                    }
                }

                // Create composite and add to world
                softBody = Matter.Composite.create();
                Matter.Composite.add(softBody, bodies);
                Matter.Composite.add(softBody, constraints);
                World.add(world, softBody);


                // Phase 1: Create character mesh (always)
                createCharacterMesh(texture, bodyWidth, bodyHeight);

                // Save mesh grid params for rectangular debug rendering
                meshGridParams = {
                    startX: startX,
                    startY: startY,
                    dx: dx,
                    dy: dy,
                    rows: rows,
                    cols: cols
                };

                // Always setup ordered bodies for debug grids
                setupOrderedBodies();

                // Phase 2: Physics-to-mesh mapping is controlled by enablePhysicsMapping flag

                // Create debug grid graphics
                debugGrid = new PIXI.Graphics();
                debugGrid.visible = debugGridVisible;
                pixiApp.stage.addChild(debugGrid);

                // Create mesh debug grid graphics
                meshDebugGrid = new PIXI.Graphics();
                meshDebugGrid.visible = meshDebugGridVisible;
                pixiApp.stage.addChild(meshDebugGrid);
            });

            // Add keyboard listener to toggle debug grid
            window.addEventListener('keydown', (event) => {
                if (event.key === 'd' || event.key === 'D') {
                    debugGridVisible = !debugGridVisible;
                    if (debugGrid) {
                        debugGrid.visible = debugGridVisible;
                    }
                }
                // Toggle mesh debug grid with 'M' key
                if (event.key === 'm' || event.key === 'M') {
                    meshDebugGridVisible = !meshDebugGridVisible;
                    if (meshDebugGrid) {
                        meshDebugGrid.visible = meshDebugGridVisible;
                    }
                }
                // Toggle physics mapping with 'P' key
                if (event.key === 'p' || event.key === 'P') {
                    enablePhysicsMapping = !enablePhysicsMapping;
                    console.log('Physics-to-mesh mapping:', enablePhysicsMapping ? 'ENABLED' : 'DISABLED');
                    
                    // orderedBodies is already set up, no need to call setup again
                }
            });


            // 5. MAIN SIMULATION LOOP
            // This is the core logic: update the renderer based on the physics engine's state
            Events.on(engine, 'afterUpdate', () => {
                if (!softBody || !kapibaraMesh) return; // Wait until both are ready

                // Phase 2: Map physics positions to mesh vertices (conditional)
                if (enablePhysicsMapping && orderedBodies && meshGridParams) {
                    const vertices = kapibaraMesh.geometry.getBuffer('aVertexPosition').data;
                    const { startX, startY } = meshGridParams;
                    // Map physics positions to local mesh space
                    for (let i = 0; i < orderedBodies.length; i++) {
                        const particle = orderedBodies[i];
                        vertices[i * 2] = particle.position.x - startX;
                        vertices[i * 2 + 1] = particle.position.y - startY;
                    }
                    kapibaraMesh.geometry.getBuffer('aVertexPosition').update();
                }

                // Update debug grid visualization
                if (debugGrid && bodyGrid) {
                    debugGrid.clear();
                    debugGrid.lineStyle(1, 0xff0000, 0.5); // Red lines with 50% opacity
                    
                    // Draw horizontal lines
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols - 1; c++) {
                            const current = bodyGrid[r][c];
                            const next = bodyGrid[r][c + 1];
                            debugGrid.moveTo(current.position.x, current.position.y);
                            debugGrid.lineTo(next.position.x, next.position.y);
                        }
                    }
                    
                    // Draw vertical lines
                    for (let c = 0; c < cols; c++) {
                        for (let r = 0; r < rows - 1; r++) {
                            const current = bodyGrid[r][c];
                            const next = bodyGrid[r + 1][c];
                            debugGrid.moveTo(current.position.x, current.position.y);
                            debugGrid.lineTo(next.position.x, next.position.y);
                        }
                    }
                }

                // Update mesh debug grid visualization
                if (meshDebugGrid) {
                    meshDebugGrid.clear();
                    meshDebugGrid.lineStyle(1, 0x00ff00, 0.8); // Green lines with 80% opacity

                    // Preferred: draw rectangular axis-aligned cells using meshGridParams
                    if (meshGridParams && kapibaraMesh) {
                        // Draw true mesh quads: for each cell, connect the four mesh vertices
                        const vertices = kapibaraMesh.geometry.getBuffer('aVertexPosition').data;
                        const { rows: mRows, cols: mCols } = meshGridParams;
                        for (let r = 0; r < mRows - 1; r++) {
                            for (let c = 0; c < mCols - 1; c++) {
                                // Indices for quad corners: top-left, top-right, bottom-right, bottom-left
                                const iTL = (r * mCols + c) * 2;
                                const iTR = (r * mCols + (c + 1)) * 2;
                                const iBR = ((r + 1) * mCols + (c + 1)) * 2;
                                const iBL = ((r + 1) * mCols + c) * 2;

                                const xTL = vertices[iTL];
                                const yTL = vertices[iTL + 1];
                                const xTR = vertices[iTR];
                                const yTR = vertices[iTR + 1];
                                const xBR = vertices[iBR];
                                const yBR = vertices[iBR + 1];
                                const xBL = vertices[iBL];
                                const yBL = vertices[iBL + 1];

                                meshDebugGrid.moveTo(xTL, yTL);
                                meshDebugGrid.lineTo(xTR, yTR);
                                meshDebugGrid.lineTo(xBR, yBR);
                                meshDebugGrid.lineTo(xBL, yBL);
                                meshDebugGrid.lineTo(xTL, yTL);
                            }
                        }
                    } else if (kapibaraMesh) {
                        // Fallback: draw grid by connecting mesh vertices (original behavior)
                        const vertices = kapibaraMesh.geometry.getBuffer('aVertexPosition').data;
                        // Draw horizontal lines
                        for (let r = 0; r < rows; r++) {
                            for (let c = 0; c < cols - 1; c++) {
                                const currentIndex = r * cols + c;
                                const nextIndex = r * cols + c + 1;
                                const currentX = vertices[currentIndex * 2];
                                const currentY = vertices[currentIndex * 2 + 1];
                                const nextX = vertices[nextIndex * 2];
                                const nextY = vertices[nextIndex * 2 + 1];
                                meshDebugGrid.moveTo(currentX, currentY);
                                meshDebugGrid.lineTo(nextX, nextY);
                            }
                        }
                        // Draw vertical lines
                        for (let c = 0; c < cols; c++) {
                            for (let r = 0; r < rows - 1; r++) {
                                const currentIndex = r * cols + c;
                                const nextIndex = (r + 1) * cols + c;
                                const currentX = vertices[currentIndex * 2];
                                const currentY = vertices[currentIndex * 2 + 1];
                                const nextX = vertices[nextIndex * 2];
                                const nextY = vertices[nextIndex * 2 + 1];
                                meshDebugGrid.moveTo(currentX, currentY);
                                meshDebugGrid.lineTo(nextX, nextY);
                            }
                        }
                    }
                }
            });
        }

        // --- Window Resize Handling ---
        function handleResize() {
            if (pixiApp) {
                pixiApp.renderer.resize(window.innerWidth, window.innerHeight);

                // Remove the old walls and add new ones that fit the new window size
                World.remove(world, [ground, wallLeft, wallRight, ceiling]);
                addWalls();
            }
        }

        // --- Start and Event Listeners ---
        window.addEventListener('load', init);
        window.addEventListener('resize', handleResize);

    </script>
</body>

</html>