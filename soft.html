<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soft Body Sprite Simulation</title>
    <style>
        /* Basic styles to make the canvas fill the entire screen */
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #2c3e50;
            /* A dark slate background */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <!-- CDN imports for the physics and rendering libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js"></script>

    <script>
        // --- Core Setup ---

        // Set up aliases for Matter.js modules for easier access
        const Engine = Matter.Engine;
        const Render = Matter.Render;
        const Runner = Matter.Runner;
        const Composites = Matter.Composites;
        const MouseConstraint = Matter.MouseConstraint;
        const Mouse = Matter.Mouse;
        const World = Matter.World;
        const Events = Matter.Events;
        const Body = Matter.Body;
        const Vector = Matter.Vector;

    let pixiApp, engine, world, runner, kapibaraMesh, softBody;
    let orderedBodies = null; // row-major order mapping for mesh vertices
    let bodyGrid = null;      // 2D grid of particle bodies [rows][cols]
        let ground, wallLeft, wallRight, ceiling;
        let isMagnetActive = false; // Flag to check if the mouse magnet is on

        // Define a collision category for objects the mouse can interact with
        const draggableCategory = 0x0002;

        // --- Function to add walls ---
        function addWalls() {
            const wallThickness = 50;
            const wallOptions = {
                isStatic: true,
                render: { visible: false } // We don't need to see the physics bodies
            };

            // ground
            ground = Matter.Bodies.rectangle(
                window.innerWidth / 2,
                window.innerHeight - 100 + wallThickness / 2,
                window.innerWidth + wallThickness * 2, // Make it wider to avoid corner gaps
                wallThickness,
                wallOptions
            );

            // ceiling
            ceiling = Matter.Bodies.rectangle(
                window.innerWidth / 2,
                -wallThickness / 2,
                window.innerWidth + wallThickness * 2,
                wallThickness,
                wallOptions
            );

            // left wall
            wallLeft = Matter.Bodies.rectangle(
                -wallThickness / 2,
                window.innerHeight / 2,
                wallThickness,
                window.innerHeight,
                wallOptions
            );

            // right wall
            wallRight = Matter.Bodies.rectangle(
                window.innerWidth + wallThickness / 2,
                window.innerHeight / 2,
                wallThickness,
                window.innerHeight,
                wallOptions
            );

            World.add(world, [ground, wallLeft, wallRight, ceiling]);
        }

        // --- Initialization Function ---
        function init() {
            // 1. PIXI.JS SETUP (RENDERING)
            // Create a Pixi application
            pixiApp = new PIXI.Application({
                width: window.innerWidth,
                height: window.innerHeight,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true,
                backgroundColor: 0x2c3e50,
            });
            document.body.appendChild(pixiApp.view);

            // 2. MATTER.JS SETUP (PHYSICS)
            // Create a physics engine
            engine = Engine.create();
            world = engine.world;
            world.gravity.y = 0.8; // Slightly lower gravity to reduce squashing

            // Create and run the physics engine runner
            runner = Runner.create();
            Runner.run(runner, engine);

            // 3. CREATE THE SOFT BODY (parameters only for now)
            // Define the properties of our soft body grid
            const cols = 50; // much higher resolution for smoother deformation
            const rows = 30;
            const particleOptions = {
                friction: 0.05,
                frictionStatic: 0.0,
                frictionAir: 0.03,
                restitution: 0.1,
                render: { visible: false }, // We'll render with Pixi, so hide Matter's default shapes
                // Assign our custom category to the soft body's particles
                collisionFilter: {
                    category: draggableCategory
                }
            };
            const constraintOptions = {
                stiffness: 0.98, // Very stiff to minimize visible grid lines
                damping: 0.5,    // High damping to reduce oscillations
                render: { visible: false }
            };

            // Add level boundaries
            addWalls();


            // 4. CONNECT PHYSICS TO RENDERING
            // Load the sprite texture for Pixi.js
            const texture = PIXI.Texture.from('./sprites/kapibara.png');

            // Build physics body and mesh AFTER the texture loads so we can match its aspect ratio
            texture.baseTexture.once('loaded', () => {
                // Improve texture sampling quality
                texture.baseTexture.scaleMode = PIXI.SCALE_MODES.LINEAR;
                texture.baseTexture.mipmap = PIXI.MIPMAP_MODES.ON;
                const aspect = texture.height / texture.width;
                const maxWidth = Math.min(window.innerWidth * 0.6, texture.width);
                const bodyWidth = maxWidth;
                const bodyHeight = bodyWidth * aspect;

                const startX = window.innerWidth / 2 - bodyWidth / 2;
                const startY = window.innerHeight / 2 - bodyHeight / 2 - 50; // small offset up

                // Compute exact spacing to match mesh dimensions
                const dx = bodyWidth / (cols - 1);
                const dy = bodyHeight / (rows - 1);
                const particleSize = Math.min(dx, dy) * 0.05; // Very small particles to minimize visual impact

                // Create bodies in exact grid positions matching PlaneGeometry
                bodyGrid = Array.from({ length: rows }, () => Array(cols).fill(null));
                const bodies = [];
                
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const x = startX + c * dx;
                        const y = startY + r * dy;
                        const body = Matter.Bodies.circle(x, y, particleSize, particleOptions);
                        bodyGrid[r][c] = body;
                        bodies.push(body);
                    }
                }

                // Create constraints between adjacent bodies
                const constraints = [];
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const current = bodyGrid[r][c];
                        
                        // Horizontal constraint (right neighbor)
                        if (c < cols - 1) {
                            const right = bodyGrid[r][c + 1];
                            constraints.push(Matter.Constraint.create({
                                bodyA: current,
                                bodyB: right,
                                stiffness: constraintOptions.stiffness,
                                damping: constraintOptions.damping,
                                render: { visible: false }
                            }));
                        }
                        
                        // Vertical constraint (bottom neighbor)
                        if (r < rows - 1) {
                            const bottom = bodyGrid[r + 1][c];
                            constraints.push(Matter.Constraint.create({
                                bodyA: current,
                                bodyB: bottom,
                                stiffness: constraintOptions.stiffness,
                                damping: constraintOptions.damping,
                                render: { visible: false }
                            }));
                        }
                        
                        // Cross braces for stability
                        if (r < rows - 1 && c < cols - 1) {
                            const bottomRight = bodyGrid[r + 1][c + 1];
                            constraints.push(Matter.Constraint.create({
                                bodyA: current,
                                bodyB: bottomRight,
                                stiffness: constraintOptions.stiffness * 0.3,
                                damping: constraintOptions.damping,
                                render: { visible: false }
                            }));
                        }
                        
                        if (r < rows - 1 && c > 0) {
                            const bottomLeft = bodyGrid[r + 1][c - 1];
                            constraints.push(Matter.Constraint.create({
                                bodyA: current,
                                bodyB: bottomLeft,
                                stiffness: constraintOptions.stiffness * 0.3,
                                damping: constraintOptions.damping,
                                render: { visible: false }
                            }));
                        }

                        // Add bending constraints (skip-one connections) to reduce grid artifacts
                        if (c < cols - 2) {
                            const rightSkip = bodyGrid[r][c + 2];
                            constraints.push(Matter.Constraint.create({
                                bodyA: current,
                                bodyB: rightSkip,
                                stiffness: constraintOptions.stiffness * 0.2,
                                damping: constraintOptions.damping * 0.5,
                                render: { visible: false }
                            }));
                        }
                        
                        if (r < rows - 2) {
                            const bottomSkip = bodyGrid[r + 2][c];
                            constraints.push(Matter.Constraint.create({
                                bodyA: current,
                                bodyB: bottomSkip,
                                stiffness: constraintOptions.stiffness * 0.2,
                                damping: constraintOptions.damping * 0.5,
                                render: { visible: false }
                            }));
                        }
                    }
                }

                // Create composite and add to world
                softBody = Matter.Composite.create();
                Matter.Composite.add(softBody, bodies);
                Matter.Composite.add(softBody, constraints);
                World.add(world, softBody);

                // Simple row-major ordering to match PlaneGeometry exactly
                orderedBodies = [];
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        orderedBodies.push(bodyGrid[r][c]);
                    }
                }

                // Create matching plane geometry (same cols/rows) with preserved aspect ratio
                const planeGeom = new PIXI.PlaneGeometry(bodyWidth, bodyHeight, cols - 1, rows - 1);
                kapibaraMesh = new PIXI.Mesh(planeGeom, new PIXI.MeshMaterial(texture));
                pixiApp.stage.addChild(kapibaraMesh);
            });

            // 5. MOUSE INTERACTION
            // Add mouse controls to interact with the physics world
            const mouse = Mouse.create(pixiApp.view);
            const mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.2,
                    render: {
                        visible: false // Don't show the default constraint line
                    }
                },
                // Configure the mouse to ONLY interact with the draggable category
                collisionFilter: {
                    mask: draggableCategory
                }
            });

            World.add(world, mouseConstraint);

            // The `Mouse.create` function in Matter.js automatically handles
            // adding the necessary mouse event listeners to the canvas.
            // The manual listeners that were here before were redundant and
            // caused the error because the Matter.js API has changed.

            // Add event listeners to the canvas to handle the magnet effect
            pixiApp.view.addEventListener('mousedown', () => { isMagnetActive = true; });
            pixiApp.view.addEventListener('mouseup', () => { isMagnetActive = false; });
            pixiApp.view.addEventListener('mouseout', () => { isMagnetActive = false; }); // Turn off if mouse leaves canvas


            // 6. MAIN SIMULATION LOOP
            // This is the core logic: update the renderer based on the physics engine's state
            Events.on(engine, 'afterUpdate', () => {
                if (!softBody || !kapibaraMesh) return; // Wait until both are ready
                // --- Magnet Logic ---
                if (isMagnetActive) {
                    const mousePosition = mouseConstraint.mouse.position;
                    // Adjust this value for stronger/weaker pull.
                    const magnetStrength = 0.00025;

                    for (const particle of softBody.bodies) {
                        const direction = Vector.sub(mousePosition, particle.position);
                        const distanceSq = Vector.magnitudeSquared(direction);

                        // Apply force only if the particle is not extremely close to the mouse
                        // This prevents wild physics glitches when the distance is near zero.
                        if (distanceSq > 25) {
                            const forceMagnitude = (magnetStrength * particle.mass * 100) / distanceSq;
                            const force = Vector.normalise(direction);
                            Vector.mult(force, forceMagnitude, force);
                            Body.applyForce(particle, particle.position, force);
                        }
                    }
                }

                const vertices = kapibaraMesh.geometry.getBuffer('aVertexPosition').data;

                // Iterate through all the particles in our soft body
                const bodies = orderedBodies || softBody.bodies;
                for (let i = 0; i < bodies.length; i++) {
                    const particle = bodies[i];
                    // Update the corresponding vertex in the Pixi mesh
                    vertices[i * 2] = particle.position.x;
                    vertices[i * 2 + 1] = particle.position.y;
                }

                // Tell Pixi that the geometry has been updated and needs to be redrawn
                kapibaraMesh.geometry.getBuffer('aVertexPosition').update();
            });
        }

        // --- Window Resize Handling ---
        function handleResize() {
            if (pixiApp) {
                pixiApp.renderer.resize(window.innerWidth, window.innerHeight);

                // Remove the old walls and add new ones that fit the new window size
                World.remove(world, [ground, wallLeft, wallRight, ceiling]);
                addWalls();
            }
        }

        // --- Start and Event Listeners ---
        window.addEventListener('load', init);
        window.addEventListener('resize', handleResize);

    </script>
</body>

</html>